import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans


# 1. Dateneinlesen und -aufbereitung
def read_and_prepare_dataset(dataset_path):
    df = pd.read_csv(dataset_path)
    df['time'] = pd.to_datetime(df['time'], format='%Y%m%d:%H%M')
    df.rename(columns={
        "G(i) (Globalstrahlung)": "global_radiation",
        "H_sun (Sonnenscheindauer in min)": "sunshine_duration",
        "T2m (Temperatur)": "temperature",
        "WS10m (Windgeschwindigkeit)": "wind_speed"
    }, inplace=True)
    df['month'] = df['time'].dt.month
    df['hour'] = df['time'].dt.hour
    df['date'] = df['time'].dt.date
    return df


# Datensatz laden
df = read_and_prepare_dataset('Timeseries_2020_2023.csv')

# 2. Berechnung der empirischen CDF pro Monat und Stunde
# Erstelle ein Lookup-Dictionary, in dem für jeden Monat und jede Stunde die sortierten Messwerte und die zugehörige CDF abgelegt werden
cdf_lookup = {}
months = sorted(df['month'].unique())
for month in months:
    cdf_lookup[month] = {}
    for hour in range(24):
        hour_data = df[(df['month'] == month) & (df['hour'] == hour)]['global_radiation'].dropna().values
        if len(hour_data) == 0:
            continue
        sorted_data = np.sort(hour_data)
        cdf = np.arange(1, len(sorted_data) + 1) / len(sorted_data)
        cdf_lookup[month][hour] = (sorted_data, cdf)


# 3. Monte-Carlo-Simulation: Tagesprofile mittels inverser CDF für jeden Monat
def simulate_daily_profile(month, n_simulations=1000):
    """
    Simuliert n_simulations Tagesprofile (24 Werte pro Tag) für einen gegebenen Monat.
    Für jede Stunde wird ein Zufallswert über die inverse CDF generiert.
    """
    daily_profiles = []  # Liste für simulierte Tagesprofile (jedes ein Array mit 24 Werten)
    for i in range(n_simulations):
        profile = []
        for hour in range(24):
            if hour in cdf_lookup[month]:
                sorted_data, cdf = cdf_lookup[month][hour]
                u = np.random.uniform(0, 1)
                # Inverse CDF mittels Interpolation
                value = np.interp(u, cdf, sorted_data)
                profile.append(value)
            else:
                profile.append(np.nan)
        daily_profiles.append(profile)
    return np.array(daily_profiles)


# 4. Szenarioreduktion und Speicherung für alle Monate
# Wir definieren hier, wie viele repräsentative Tagesprofile (Cluster) pro Monat genutzt werden sollen.
# Diesen Wert kannst du je nach Detailgrad und Komplexität deines Optimierungsmodells anpassen.
clusters_per_month = 5  # Beispiel: 5 repräsentative Szenarien pro Monat

all_rep_profiles = []  # Liste zum Speichern aller repräsentativen Profile

for month in months:
    print(f"Simuliere und clustere für Monat {month} ...")
    simulated_profiles = simulate_daily_profile(month, n_simulations=1000)

    # Prüfe, ob genügend Daten vorliegen
    if simulated_profiles.shape[0] < clusters_per_month:
        continue

    # Clustere die simulierten Tagesprofile mit KMeans
    kmeans = KMeans(n_clusters=clusters_per_month, random_state=42).fit(simulated_profiles)
    labels = kmeans.labels_
    centers = kmeans.cluster_centers_

    # Berechne die Wahrscheinlichkeit für jedes Cluster
    unique, counts = np.unique(labels, return_counts=True)
    cluster_probs = {cl: count / simulated_profiles.shape[0] for cl, count in zip(unique, counts)}

    # Speichere die Ergebnisse für den aktuellen Monat
    for cl in unique:
        all_rep_profiles.append({
            'month': month,
            'cluster': int(cl),
            'profile': centers[cl].tolist(),
            'probability': cluster_probs[cl]
        })

# Konvertiere die Ergebnisse in ein DataFrame und erweitere das 24-Stunden-Profil in separate Spalten
rep_df = pd.DataFrame(all_rep_profiles)
profile_df = rep_df['profile'].apply(pd.Series)
profile_df.columns = [f'hour_{h}' for h in range(24)]
rep_df = pd.concat([rep_df.drop(columns=['profile']), profile_df], axis=1)
rep_df.sort_values(by=['month', 'cluster'], inplace=True)

# Speichere die repräsentativen Szenarien in einer CSV-Datei
rep_df.to_csv('representative_daily_profiles_all_months.csv', index=False)
print(
    "Repräsentative Tagesprofile für alle Monate wurden in 'representative_daily_profiles_all_months.csv' gespeichert.")

# 5. Beispielhafte Visualisierung eines Monats (z.B. Juli)
example_month = 7
example_profiles = rep_df[rep_df['month'] == example_month]
plt.figure(figsize=(10, 6))
for idx, row in example_profiles.iterrows():
    hours = np.arange(24)
    plt.plot(hours, row[[f'hour_{h}' for h in hours]], marker='o',
             label=f'Cluster {row["cluster"]} (p={row["probability"]:.2f})')
plt.xlabel('Stunde des Tages')
plt.ylabel('Globalstrahlung')
plt.title(f'Repräsentative Tagesprofile im Monat {example_month}')
plt.legend()
plt.grid(True)
plt.show()
